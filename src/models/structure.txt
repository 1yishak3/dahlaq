Things that have to be tracked for change:

Basic in profile
Properties in profile
Summary in Chat
Messages in Chat
Posts
FameList
I'll have to look at the database and add some.

//ToDo

Posts don't work after message sending fixed

File browsing plugin yasfelgal cause it's not working for fren ---ish This will be postponed


Firebase functions need caching fix
and fame list updates must MUST MUST include username to make things easier during searches. Peace.


If:

Try implementing the inAppBrowser thing eski






<div class="talk-bubble round" *ngIf="message.sender===oUser&&(message.time>messages[i-1].time-60000&&message.time<messages[i-1].time+60000)">
  <ion-row>
    <img *ngIf="message.picture!==''" [src]="message.picture"/>

    <div [innerHtml]="message.content|linky"></div>
  </ion-row>
  <ion-row>
    <ion-col col-3>
      {{message.time|momentjs}}
    </ion-col>
  </ion-row>
</div>
<div class="talk-bubble tri-right round left-top" *ngIf="message.sender===oUser&&(message.time<messages[i-1].time-60000||message.time>messages[i-1].time+60000)">
  <ion-row>
      <img *ngIf="message.picture!==''" [src]="message.picture"/>
    <div [innerHtml]="message.content|linky"></div>
  </ion-row>
  <ion-row>
    <ion-col col-3>
      {{message.time|momentjs}}
    </ion-col>
  </ion-row>
</div>
<div class="talk-bubble round" *ngIf="message.sender===user&&(message.time>messages[i-1].time-60000&&message.time<messages[i-1].time+60000)">
  <ion-row>
      <img *ngIf="message.picture!==''" [src]="message.picture"/>
    <div [innerHtml]="message.content|linky"></div>
  </ion-row>
  <ion-row>
    <ion-col col-11>
      {{message.time|momentjs}}
    </ion-col>
    <ion-col col-1>
      <ion-icon color="light" name="checkmark" *ngIf="message.sent&&!message.read"></ion-icon>
      <ion-icon color="primary" name="checkmark" *ngIf="message.read"></ion-icon>
    </ion-col>
  </ion-row>
</div>
<div class="talk-bubble tri-right round right-top" *ngIf="message.sender===user&&(message.time<messages[i-1].time-60000||message.time>messages[i-1].time+60000)">
  <ion-row>
      <img *ngIf="message.picture!==''" [src]="message.picture"/>
    <div [innerHtml]="message.content|linky"></div>
  </ion-row>
  <ion-row>
    <ion-col col-11>
      {{message.time|momentjs}}
    </ion-col>
    <ion-col col-1>
      <ion-icon color="light" name="checkmark" *ngIf="message.sent&&!message.read"></ion-icon>
      <ion-icon color="primary" name="checkmark" *ngIf="message.read"></ion-icon>
    </ion-col>
  </ion-row>
</div>

What the data will look like.
#habeshaHi!

Legend: txt=text
        #=number/unique identification system
        bool=boolean
a post ID will be represented by

{{uid}}+{{time}}

A message thread ID will be represented by

{{UserName1}}+{{UserName2}}+{{Date_Started}}



Users will have the following properties

 User: {
   "preferences":[{"uid":"//likiliness(normal probability=0.5)"},{}],
   "likes":[{
     "postId":"",
     "time":"the time it was liked"
     },{}
   ],
   "dislikes":[{
     "postId":"",
     "time":"the time it was disliked"
     },{}
   ],
   "reports":[{"postId":"","time":"time it was reported"],
   "userPosts":["postId"],
   "properties":{
     "username":"txt",
     "digits":"txt",
     "fame":"#",
     "bio":"txt",
     "city":"txt",
     "food":"txt",
     "rank":"#",
     "education":"txt",
     "relationshipStatus":"txt"
   },
   "people":{"threadID"{
     "senderName":"txt",
     "userName":"txt"
     "senderDigits":"#",
     "lastMessage":"txt",

   },},
   "viewables":["postID",""]

 }


 Chats will be like this

 "chats":{"threadID":[
   "messages_":[
     {
       "sender":"username",
       "receiver":"username",
       "content":"ABC",
       "time":"time"
     }
   ]
 ]}

 Posts will be like this


"posts": {
   "postId":"",
   "time":"#time",
   "poster":{
     "username":"#A",
     "digits":"##",
     "uId":"#",
     "userImage":"",
     "desiredReach":""
   },
   "content":{
     "desciption":"",
     "imageUrl":"",
     "likes":[{"userId":"","time":""},{}],
     "dislikes":[{"userId":"","time":""},{}],
     "reports":[{"userId":"","time":""}],
     "reach":[{"userId":"","time":""}],
     "boosts":[{"userId":"","time":"","bReach":""}]
   },
   "deleted":""
 }

Sample= [
  {
    user: {
      avatar: 'assets/img/marty-avatar.png',
      name: 'Marty McFly'
    },
    date: 'November 5, 1955',
    image: 'assets/img/advance-card-bttf.png',
    content: 'Wait a minute. Wait a minute, Doc. Uhhh... Are you telling me that you built a time machine... out of a DeLorean?! Whoa. This is heavy.',
  },
  {
    user: {
      avatar: 'assets/img/sarah-avatar.png.jpeg',
      name: 'Sarah Connor'
    },
    date: 'May 12, 1984',
    image: 'assets/img/advance-card-tmntr.jpg',
    content: 'I face the unknown future, with a sense of hope. Because if a machine, a Terminator, can learn the value of human life, maybe we can too.'
  },
  {
    user: {
      avatar: 'assets/img/ian-avatar.png',
      name: 'Dr. Ian Malcolm'
    },
    date: 'June 28, 1990',
    image: 'assets/img/advance-card-jp.jpg',
    content: 'Your scientists were so preoccupied with whether or not they could, that they didn\'t stop to think if they should.'
  }
];






SECURITY IS AN ISSUE RIGHT NW. A USER MUST NOT BE ABLE TO GET TO ANOTHER USERS PROFILE AND EDIT IT IN ANY WAY.
THIS NEEDS SOME WORK, BUT NOT AN ISSUE FOR MVP MAYBE?







Add a list of Uids to the root of your Database, it will be much faster to iterate through them and check until the
post number reaches 20 instead of loading the ENTIRE user data just to do that same thing.




Your Users list can be ordered according to the fame level, this would reduce work for and will be
done inside one of your cloud functions.

The backend functions must do a lot more than what user currently requires, because the user will
always need more really soon. We don't want to access the backend on a request bases...although that would be more efficient. we need
to think about this a bit more.

We'll take care of preferences issues last, we might omit for mvp.

I say strike a deal with the government that you will destroy photos of exams and as such in exchange
for unblockability. If they refuse, you can still uphold your claim, but be against the government.
As if you have anything to loose...
Okay, great. Either way, more users for me, and more ads. Cool.

Everytime someone's key properties change, a cloud function is triggered and calculates
the person's new fame level. Okay good. But what happens next?
Sorting the entire user list again for the sake of a single like is very very expensive.
we need to figure out a sorting method.

 //TODO:


 You need to add Local Forage features to check first time usage and as such.

 Caching should also be a thing, and I think local forage should be a great way to do it

 For tonight, try to get data from the user about their post and add that to your post object.
 will use firebase to send that post to the database, where it will be processed

 Also work on that settings page ONLY AUTHENTICATED USER can access.


 Messages are going to be dynamic. User's side continuously listens to new messages and visualizes the text be typed. Like a live stream. not so difficult
 You can update the firebase info on the go until the typer hits the send button, at which point updating the message halts indefinitely. This starts at the placement of the
 in the text area and ends at the touch of the send button.
 Don't forget the read unread thing. It won't be hard but you know, still.


 All images videos and files are to be kept inside the storage and will be linked to the realtime database



My Fame Structure
First List: I'll have a list of users (DB Name: fameList)
Second List: and I'll have a list of fames each corresponding to the index of its user(with uid) on the first list (DB name: uidList)
Third List: the second list will then get a list of usernames corresponding to the index. (DB name: nameList)
After this, at the trigger of a like dislike or report, the fame of the person will be recalculated.
after recalculation, the value is compared with the previous fame level and a signal containing "greater" or "less" is sent out with the fame.
this will reduce time wastage by comparing the fame value to just one side rather than both.
At the trigger of the recalculation, the fame at the current index of the user on the first list
will be compared to one of its neighbors (of course depending on that greater or less value),
if the neighbor is less or more (again according to that value), the fame level exchanges positions with that index and exchanges the position
at the first list accordingly. this process will continue until the next index fame becomes greater or less than the fame value
we are talking about.
The same can go for notoriety but we can hold this of until we are done with everything MVP(MINIMUM VIABLE PRODUCT)

let arr = ["alice", "bob", "mallory"];
let obj = arr.reduce((acc, val) => {
  let key = firebase.database().ref().push().key;
  acc[key] = val;
  return acc;
}, {});

fix everything considering the assumption that arrays won't exist inside firebase except as objects.
then move on to the finalization of the rank page and do messaging. Please do this quick.

Things to think about:

A like, dislike, report's effects on both the poster and the post reader
Cloud messaging and how to integrate that with Dahlaq

Edge cases in a user's behaviour in chat mode and picking people to talk to must be addresseed.

Caching.
Don't forget the referral mechanism (use usernames, make a list of uids and corresponding usernames object like this:

{"username":"uid"})



chat summary will look like:

{
  person1:{
    username:''
    image:''
    unread:0
  }
  person2:{
    username:''
    image:''
    unread:0
  }
  lastMessage:{

  }
  lastTime
}



bubble CSS

.speech-bubble { position: relative; background: #37484a; border-radius: .4em; }
.speech-bubble:after { content: '';
 position: absolute;
  left: 0; top: 50%;
  width: 0; height: 0;
  border: 42px solid transparent;
  border-right-color: #37484a;
  border-left: 0;
  border-bottom: 0;
  margin-top: -21px;
  margin-left: -42px; }



































































A platform
customizable
ad machine
